<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Lab Week 4 - CS 12 SI Labs: Winter 2015</title>
  

  <link rel="shortcut icon" href="../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Lab Week 4";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> CS 12 SI Labs: Winter 2015</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Home</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../lab_week_03/">Lab Week 3</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Lab Week 4</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#lab-4-classes-syntactical-sugar-compilation-and-makefiles">Lab 4: Classes, Syntactical Sugar, Compilation, and Makefiles</a></li>
                
                    <li><a class="toctree-l4" href="#this">This</a></li>
                
                    <li><a class="toctree-l4" href="#overloading">Overloading</a></li>
                
                    <li><a class="toctree-l4" href="#classes-within-classes">Classes Within Classes</a></li>
                
                    <li><a class="toctree-l4" href="#preprocessor-directives">Preprocessor Directives</a></li>
                
                    <li><a class="toctree-l4" href="#separate-files">Separate Files</a></li>
                
                    <li><a class="toctree-l4" href="#inclusion-guards">Inclusion Guards</a></li>
                
            
            </ul>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">CS 12 SI Labs: Winter 2015</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Lab Week 4</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="lab-4-classes-syntactical-sugar-compilation-and-makefiles">Lab 4: Classes, Syntactical Sugar, Compilation, and Makefiles</h1>
<h2 id="this">This</h2>
<pre><code class="c++">class Foo {
    public:
        Foo() {
            this-&gt;a = 0;
            this-&gt;b = 0;
        }
        Foo(int a, int b) {
            // now, which &quot;a&quot; does &quot;a&quot; refer to?
            /* this doesn't work for obvious reasons:
            a = a;
            b = b;
            */
            // using &quot;this&quot; helps us clear the confusion up
            this-&gt;a = a; // a is the parameter
            this-&gt;b = b; // b is the parameter
        }
    private:
        int a, b;
};
</code></pre>

<p>The keyword <code>this</code> is used to access the implicit parameter's fields.
To use access fields of the implicit parameter, use the arrow operator (<code>-&gt;</code>).</p>
<h2 id="overloading">Overloading</h2>
<p><a href="https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B" target="_blank">This</a> article contains a list of all C++ operators and whether or not they are able to be overloaded.
Operators can be overloaded as part of a class, or outside of class definitions.
When overloading as part of a class, the object referred to by <code>this</code> is assumed to be the first parameter of the operator being overloaded.
Also, the overloaded operator can operate on and with private data and private member functions.</p>
<p>Operators overloaded globally must specify all parameters to the operator in question.
Because they are defined outside of the class, they cannot access private data or private member functions unless the operator is made to be a <code>friend</code>.</p>
<h2 id="classes-within-classes">Classes Within Classes</h2>
<p><a href="https://zybooks.zyante.com/#/zybook/UCRCS12Winter2016/chapter/9/section/17" target="_blank">Chapter 9 section 17 in your book</a> talks about using classes within classes.
Nothing special is happening here;
once a class is created, it can be used just about anywhere.</p>
<pre><code class="c++">class A {
    private:
        int x, y;
    public:
        A(int x, int y) : x(x), y(y) {}
        void setX(int x) { this-&gt;x = x; }
        void setY(int y) { this-&gt;y = y; }
        int  getX()      { return x; }
        int  getY()      { return y; }
};

class B {  // contains instances of A
    private:
        A pv1, pv2;
};
</code></pre>

<h2 id="preprocessor-directives">Preprocessor Directives</h2>
<p>Preprocessor directives are very powerful tools that a programmer can use to make code more quickly.
All preprocessor directives start with the <a href="http://www.merriam-webster.com/dictionary/octothorpe" target="_blank">octothorpe</a> (<code>#</code>).</p>
<pre><code class="c++">#include &lt;filename.h&gt;
#include &quot;filename.h&quot;
</code></pre>

<p>The <code>#include</code> directive finds a file specified, and places its contents where the <code>#include</code> statement was located.
When the filename is surrounded with angle brackets (<code>&lt;&gt;</code>), the preprocessor will look in standard library locations for your file.
When the filename is surrounded with quotation marks (<code>""</code>), the preprocessor will look for the file in the same directory as the file you're trying to compile.</p>
<h2 id="separate-files">Separate Files</h2>
<p>When programs become very large, it is a good idea to split them up into smaller logical units so they are easier to maintain.
There is a way to do this that also has the added benefit of allowing for separate compilation;
instead of compiling every part of your program every time you want to build an executable, you can instead separate the code in such a way that only parts you change need to be recompiled.</p>
<pre><code class="c++">/* main.cpp */

#include &lt;iostream&gt;

class Foo { // class declaration
    public:
        Foo();        // default constructor
        void hello(); // some function
        // stuff
        // ...
    private:
        // stuff
        // ...
};

// class definition
Foo::Foo() {}

void Foo::hello() {
    std::cout &lt;&lt; &quot;hello world&quot; &lt;&lt; std::endl;
}

int main() {
    Foo a;
    a.hello();
}
</code></pre>

<p>Let's say we're working with the single file <code>main.cpp</code> above.
How would we break it up?
Start by taking out the class and putting it in another file.
We'll call it <code>foo.cpp</code>.</p>
<pre><code class="c++">/* foo.cpp */

#include &lt;iostream&gt;

class Foo { // class declaration
    public:
        Foo();        // default constructor
        void hello(); // some function
        // stuff
        // ...
    private:
        // stuff
        // ...
};

// class definition
Foo::Foo() {}

void Foo::hello() {
    std::cout &lt;&lt; &quot;hello world&quot; &lt;&lt; std::endl;
}
</code></pre>

<pre><code class="c++">/* main.cpp */

#include &quot;foo.cpp&quot;

int main() {
    Foo a;
    a.hello();
}
</code></pre>

<p>Notice that <code>main.cpp</code> doesn't actually use anything from <code>iostream</code>, so it is not necessary to include it there.
This is a good first step.
We have logically separated all of the parts of our simple program.
Generally, each class will have its own file(s) containing all the code associated with it.</p>
<p>What about the separate compilation I promised?
If you understand preprocessor directives, you can tell that we're basically ending up with our original <code>main.cpp</code>, just using extra steps.
Let's fix that:</p>
<pre><code class="c++">/* foo.h */

#include &lt;iostream&gt;

class Foo { // class declaration
    public:
        Foo();        // default constructor
        void hello(); // some function
        // stuff
        // ...
    private:
        // stuff
        // ...
};
</code></pre>

<pre><code class="c++">/* foo.cpp */

#include &quot;foo.h&quot;

// class definition
Foo::Foo() {}

void Foo::hello() {
    std::cout &lt;&lt; &quot;hello world&quot; &lt;&lt; std::endl;
}
</code></pre>

<pre><code class="c++">/* main.cpp */

#include &quot;foo.h&quot;

int main() {
    Foo a;
    a.hello();
}
</code></pre>

<p>Wow!
Three files!!
Now, we can perform separate compilation.
Previously, <code>g++ main.cpp</code> would have done the trick for us.
Now, that won't work.
Instead, we compile like this:</p>
<pre><code class="sh">g++ -c foo.cpp
g++ -c main.cpp
g++ foo.o main.o
</code></pre>

<p>Alternatively, you could compile like this:</p>
<pre><code class="sh">g++ -c foo.cpp
g++ main.cpp foo.o
</code></pre>

<p>Remember how we are allowed to use prototypes for compilation, and give actual function definitions at a later point?
This is because there are actually two steps to building an executable.
The first is the compilation step.
All the code you write gets turned into machine language.
Next is the linking step.
All the functions you used get "linked" into your executable.
You don't need to know the details of linking, but basically during compilation, a placeholder is put in for each function call, which is then filled in with an actual, correct value later.</p>
<p>Knowing this, let's explore what's happening in the code above.
When we attempt to compile <code>foo.cpp</code>, <code>foo.cpp</code> brings in <code>foo.h</code>.
No reason to type anything twice, so we keep the class declaration in one spot, and that's usually the header file (ending in <code>.h</code>).
There's no <code>main</code> function, but this is okay because we're only compiling for now.
We tell the compiler to only compile by sending the <code>-c</code> flag.</p>
<p>Next, we attempt to compile <code>main.cpp</code>.
The only thing <code>main.cpp</code> needs to know to be compiled are the prototypes of <code>Foo</code>, and nothing else!
We're not linking yet, so we don't need the definitions.</p>
<p>Lastly, we link everything together.
When compiling, we get <em>object code</em>.
The file generated usually has the same name as the file compiled, but with a <code>.o</code> exstension instead of the original <code>.cpp</code>.</p>
<p>In the first compilation example, I created two object files, <code>main.o</code> and <code>foo.o</code>, and linked them together.
In the second compilation example, I created one object file, <code>foo.o</code>, and then compiled and linked <code>main.cpp</code> in a single step.
Either way works, and is a matter of style.
The former is usually more preferable, because it's easier to remember;
just do the exact same thing for all files, then link everything together!
Both allow for separate compilation.</p>
<p>But what does separate compilation mean, exactly?
If I were to change <code>main.cpp</code> to the following:</p>
<pre><code class="c++">/* main.cpp */

#include &quot;foo.h&quot;

int main() {
    Foo a, b;
    a.hello();
    b.hello();
}
</code></pre>

<p>The only thing I would need to do to recompile is the following:</p>
<pre><code class="sh">g++ -c main.cpp
g++ main.o foo.o
</code></pre>

<p>Notice how I did <strong>not</strong> recompile <code>foo.cpp</code>!
The old <em>definitions</em> for <code>Foo</code> are still in <code>foo.o</code>, so I can still use it (assuming you didn't delete it).
Now imagine if you have many large classes included in your project.
Compiling the entire project every time you wanted to run it could be a time-consuming process.
It may take sever minutes to several hours, for larger projects.
A solution to this problem is separate compilation;
organize your files in such a way that you don't need to compile everything every time.</p>
<p>NOTE: This doesn't mean you don't have to compile anything.
You still need to compile everything you <em>change</em>.
If you change how <code>Foo</code> works, or add a function, you need to recompile and relink everything you change.</p>
<h2 id="inclusion-guards">Inclusion Guards</h2>
<p>Separate compilation is great, but there's one problem:
what do I do if my header gets included in multiple places?
We can use preprocessor directives to make sure it only ever gets included once.</p>
<pre><code class="c++">/* foo.h */

#ifndef FOO_H
#define FOO_H

#include &lt;iostream&gt;

class Foo { // class declaration
    public:
        Foo();        // default constructor
        void hello(); // some function
        // stuff
        // ...
    private:
        // stuff
        // ...
};

#endif
</code></pre>

<p><code>#ifndef</code> asks the preprocessor if the term <code>FOO_H</code> is defined.
If it isn't, everything until the <code>#endif</code> is left in its place.
Otherwise, if the term <code>FOO_H</code> has already been defined, everything until the <code>#endif</code> is removed (not permanently, of course, just for the purposes of compilation).
The <code>#define</code> defines the term <code>FOO_H</code> so the code can only ever be included for compilation once.</p>
<p>It's not a rule, but good practice is to name the defined term similarly to your header file.
Also, capitalizing every letter shows that it's a defined term.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../lab_week_03/" class="btn btn-neutral" title="Lab Week 3"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../lab_week_03/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
    </span>
</div>

</body>
</html>
