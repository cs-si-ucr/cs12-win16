{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to CS12 SI!\n\n\nThis is where all of the labs will be posted.\n\n\nWhat is SI?\n\n\nSupplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.\n\n\nWhat isn\u2019t SI?\n\n\nSupplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.\n\n\nWho should go?\n\n\nAnyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.\n\n\nHowever, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 10 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.\n\n\nWith that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.\n\n\nGuidelines:\n\n\n\n\nBe respectful - This includes silencing your cell phones\nand not using them during sessions.\n\n\nParticipate - You won\u2019t get very much out of SI if you\ndon\u2019t.\n\n\nNo food or drink besides water - This is a rule placed\nby the administration. I will enforce it.\n\n\nLate entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.\n\n\nSign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-cs12-si", 
            "text": "This is where all of the labs will be posted.", 
            "title": "Welcome to CS12 SI!"
        }, 
        {
            "location": "/#what-is-si", 
            "text": "Supplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.", 
            "title": "What is SI?"
        }, 
        {
            "location": "/#what-isnt-si", 
            "text": "Supplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.", 
            "title": "What isn\u2019t SI?"
        }, 
        {
            "location": "/#who-should-go", 
            "text": "Anyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.  However, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 10 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.  With that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.", 
            "title": "Who should go?"
        }, 
        {
            "location": "/#guidelines", 
            "text": "Be respectful - This includes silencing your cell phones\nand not using them during sessions.  Participate - You won\u2019t get very much out of SI if you\ndon\u2019t.  No food or drink besides water - This is a rule placed\nby the administration. I will enforce it.  Late entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.  Sign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Guidelines:"
        }, 
        {
            "location": "/lab_week_03/", 
            "text": "Lab 3: Structs and Classes\n\n\nStructs\n\n\nStructs are a way to create new datatypes that are combinations of smaller datatypes.\n\n\nHere's the syntax for creating a struct:\n\n\nstruct StructName {\n    Type1 field1;\n    Type2 field2;\n    // ...\n};  // \n-- Notice this semicolon\n\n\n\n\nAfter this point, there now exists a new type - a struct - called \nStructName\n, and it can be used like so:\n\n\nStructName myStruct;\nmyStruct.field1;     // expression of type Type1\nmyStruct.field2;     // expression of type Type2\n\n\n\n\nStructs define different fields.\nEach field gets its own type.\nWhen using the struct, each field is available through the dot operator.\n\n\nNow, you can use your new type like you would any other type.\n\n\n/* in containers */\nvector\nStructName\n v(20);        // a vector of StructName with a size of 20\n\n/* functions */\nvoid f1(StructName arg1);        // accepts StructName by value\nvoid f1(StructName\n arg1);       // accepts StructName by reference\nvoid f1(const StructName\n arg1); // accepts StructName by const reference\n\nStructName f2();                 // returns StructName\n\n\n\n\nClasses\n\n\nClasses are very similar to structs in that they can hold their own data.\nUnlike structs however, they can also hold contain their own methods.\n\n\nclass MyClass {\n    public:\n        Type1 publicData;\n        Type2 f1();\n    private:\n        Type3 privateData;\n        Type4 f2();\n};\n\n\n\n\nFirst, you should notice the \npublic\n and \nprivate\n keywords.\nThis is one of the big differences between structs and classes.\nIn a struct, all members are public.\nThis can't be changed.\nIn a class, the programmer decides whether each element is \npublic\n or \nprivate\n.\n\nprivate\n members can't be accessed with the dot operator.\n\n\nMyClass obj;\nobj.publicData;  // this is allowed\nobj.privateData; // this isn't allowed\n\n\n\n\nAnother difference is the concept of member functions.\nYou've already been using member functions.\nSome examples include \n.size()\n, \n.at(int)\n, and \n.find(...)\n.\n\n\nNow, combine your knowledge of member function usage and \npublic\n and \nprivate\n permissions, and it's easy to see how to use member functions:\n\n\nMyClass obj;\nobj.f1(); // allowed because it's public\nobj.f2(); // not allowed because it's private\n\n\n\n\nNotice that the parentheses mean that the member is a function, not just data.\n\n\nAn important thing you will need to learn now is \"encapsulation.\"\nThink about cars for a moment.\nTo drive a car well, you don't need to know how the engine works.\nYou don't need to keep track of every little piece;\ninstead you just focus on the steering wheel and pressing the pedals.\nSimilarly for classes, the users of your class shouldn't have access to the internal details.\nThey might mess something up!\nInstead, you provide a clean interface that abstracts the details away.\nRefer to your book on how to do this.\n\n\nAccessors, Mutators, and Private Helper Functions\n\n\nclass MyClass {\n    private:\n        Type data;\n        void helper();\n\n    public:\n        void accessor(int x) const; // this function can't change any private data\n        void mutator(int x);        // this function can change private data\n};\n\n\n\n\nMutators aren't \nrequired\n to change data;\nthey only have the ability to.\nAccessors that change private data will cause compiler errors.\n\n\nClass functions declared \nprivate\n are known as \"helper functions\".\nThis is due to the fact that they can only be called from within the class's own member functions.\n\n\nMyClass obj;\nobj.helper();  // not allowed\nobj.mutator(); // mutator is allowed to call helper\n\n\n\n\nNOTE: functions declared as const (accessors) aren't allowed to ever call a non-const function (mutator).\n\n\nConstructors\n\n\nclass MyClass {\n    public:\n        MyClass();      // notice: NO return type\n        MyClass(int x); // also, it can be overloaded to accept different parameters\n};\n\n\n\n\nConstructors exist to allow you to start your class at a known state.\nThey have \nno\n return type.\nWhen an object of your class is created, the constructor is called.\nIf you don't write a constructor for your class, a default constructor will be used.\n\n\nBonus\n\n\nIf you want to learn a cool trick that will make coding easier in the future, look up \ninitialization lists", 
            "title": "Lab Week 3"
        }, 
        {
            "location": "/lab_week_03/#lab-3-structs-and-classes", 
            "text": "", 
            "title": "Lab 3: Structs and Classes"
        }, 
        {
            "location": "/lab_week_03/#structs", 
            "text": "Structs are a way to create new datatypes that are combinations of smaller datatypes.  Here's the syntax for creating a struct:  struct StructName {\n    Type1 field1;\n    Type2 field2;\n    // ...\n};  //  -- Notice this semicolon  After this point, there now exists a new type - a struct - called  StructName , and it can be used like so:  StructName myStruct;\nmyStruct.field1;     // expression of type Type1\nmyStruct.field2;     // expression of type Type2  Structs define different fields.\nEach field gets its own type.\nWhen using the struct, each field is available through the dot operator.  Now, you can use your new type like you would any other type.  /* in containers */\nvector StructName  v(20);        // a vector of StructName with a size of 20\n\n/* functions */\nvoid f1(StructName arg1);        // accepts StructName by value\nvoid f1(StructName  arg1);       // accepts StructName by reference\nvoid f1(const StructName  arg1); // accepts StructName by const reference\n\nStructName f2();                 // returns StructName", 
            "title": "Structs"
        }, 
        {
            "location": "/lab_week_03/#classes", 
            "text": "Classes are very similar to structs in that they can hold their own data.\nUnlike structs however, they can also hold contain their own methods.  class MyClass {\n    public:\n        Type1 publicData;\n        Type2 f1();\n    private:\n        Type3 privateData;\n        Type4 f2();\n};  First, you should notice the  public  and  private  keywords.\nThis is one of the big differences between structs and classes.\nIn a struct, all members are public.\nThis can't be changed.\nIn a class, the programmer decides whether each element is  public  or  private . private  members can't be accessed with the dot operator.  MyClass obj;\nobj.publicData;  // this is allowed\nobj.privateData; // this isn't allowed  Another difference is the concept of member functions.\nYou've already been using member functions.\nSome examples include  .size() ,  .at(int) , and  .find(...) .  Now, combine your knowledge of member function usage and  public  and  private  permissions, and it's easy to see how to use member functions:  MyClass obj;\nobj.f1(); // allowed because it's public\nobj.f2(); // not allowed because it's private  Notice that the parentheses mean that the member is a function, not just data.  An important thing you will need to learn now is \"encapsulation.\"\nThink about cars for a moment.\nTo drive a car well, you don't need to know how the engine works.\nYou don't need to keep track of every little piece;\ninstead you just focus on the steering wheel and pressing the pedals.\nSimilarly for classes, the users of your class shouldn't have access to the internal details.\nThey might mess something up!\nInstead, you provide a clean interface that abstracts the details away.\nRefer to your book on how to do this.", 
            "title": "Classes"
        }, 
        {
            "location": "/lab_week_03/#accessors-mutators-and-private-helper-functions", 
            "text": "class MyClass {\n    private:\n        Type data;\n        void helper();\n\n    public:\n        void accessor(int x) const; // this function can't change any private data\n        void mutator(int x);        // this function can change private data\n};  Mutators aren't  required  to change data;\nthey only have the ability to.\nAccessors that change private data will cause compiler errors.  Class functions declared  private  are known as \"helper functions\".\nThis is due to the fact that they can only be called from within the class's own member functions.  MyClass obj;\nobj.helper();  // not allowed\nobj.mutator(); // mutator is allowed to call helper  NOTE: functions declared as const (accessors) aren't allowed to ever call a non-const function (mutator).", 
            "title": "Accessors, Mutators, and Private Helper Functions"
        }, 
        {
            "location": "/lab_week_03/#constructors", 
            "text": "class MyClass {\n    public:\n        MyClass();      // notice: NO return type\n        MyClass(int x); // also, it can be overloaded to accept different parameters\n};  Constructors exist to allow you to start your class at a known state.\nThey have  no  return type.\nWhen an object of your class is created, the constructor is called.\nIf you don't write a constructor for your class, a default constructor will be used.", 
            "title": "Constructors"
        }, 
        {
            "location": "/lab_week_03/#bonus", 
            "text": "If you want to learn a cool trick that will make coding easier in the future, look up  initialization lists", 
            "title": "Bonus"
        }, 
        {
            "location": "/lab_week_04/", 
            "text": "Lab 4: Classes, Syntactical Sugar, Compilation, and Makefiles\n\n\nThis\n\n\nclass Foo {\n    public:\n        Foo() {\n            this-\na = 0;\n            this-\nb = 0;\n        }\n        Foo(int a, int b) {\n            // now, which \na\n does \na\n refer to?\n            /* this doesn't work for obvious reasons:\n            a = a;\n            b = b;\n            */\n            // using \nthis\n helps us clear the confusion up\n            this-\na = a; // a is the parameter\n            this-\nb = b; // b is the parameter\n        }\n    private:\n        int a, b;\n};\n\n\n\n\nThe keyword \nthis\n is used to access the implicit parameter's fields.\nTo use access fields of the implicit parameter, use the arrow operator (\n-\n).\n\n\nOverloading\n\n\nThis\n article contains a list of all C++ operators and whether or not they are able to be overloaded.\nOperators can be overloaded as part of a class, or outside of class definitions.\nWhen overloading as part of a class, the object referred to by \nthis\n is assumed to be the first parameter of the operator being overloaded.\nAlso, the overloaded operator can operate on and with private data and private member functions.\n\n\nOperators overloaded globally must specify all parameters to the operator in question.\nBecause they are defined outside of the class, they cannot access private data or private member functions unless the operator is made to be a \nfriend\n.\n\n\nClasses Within Classes\n\n\nChapter 9 section 17 in your book\n talks about using classes within classes.\nNothing special is happening here;\nonce a class is created, it can be used just about anywhere.\n\n\nclass A {\n    private:\n        int x, y;\n    public:\n        A(int x, int y) : x(x), y(y) {}\n        void setX(int x) { this-\nx = x; }\n        void setY(int y) { this-\ny = y; }\n        int  getX()      { return x; }\n        int  getY()      { return y; }\n};\n\nclass B {  // contains instances of A\n    private:\n        A pv1, pv2;\n};\n\n\n\n\nPreprocessor Directives\n\n\nPreprocessor directives are very powerful tools that a programmer can use to make code more quickly.\nAll preprocessor directives start with the \noctothorpe\n (\n#\n).\n\n\n#include \nfilename.h\n\n#include \nfilename.h\n\n\n\n\n\nThe \n#include\n directive finds a file specified, and places its contents where the \n#include\n statement was located.\nWhen the filename is surrounded with angle brackets (\n), the preprocessor will look in standard library locations for your file.\nWhen the filename is surrounded with quotation marks (\n\"\"\n), the preprocessor will look for the file in the same directory as the file you're trying to compile.\n\n\nSeparate Files", 
            "title": "Lab Week 4"
        }, 
        {
            "location": "/lab_week_04/#lab-4-classes-syntactical-sugar-compilation-and-makefiles", 
            "text": "", 
            "title": "Lab 4: Classes, Syntactical Sugar, Compilation, and Makefiles"
        }, 
        {
            "location": "/lab_week_04/#this", 
            "text": "class Foo {\n    public:\n        Foo() {\n            this- a = 0;\n            this- b = 0;\n        }\n        Foo(int a, int b) {\n            // now, which  a  does  a  refer to?\n            /* this doesn't work for obvious reasons:\n            a = a;\n            b = b;\n            */\n            // using  this  helps us clear the confusion up\n            this- a = a; // a is the parameter\n            this- b = b; // b is the parameter\n        }\n    private:\n        int a, b;\n};  The keyword  this  is used to access the implicit parameter's fields.\nTo use access fields of the implicit parameter, use the arrow operator ( - ).", 
            "title": "This"
        }, 
        {
            "location": "/lab_week_04/#overloading", 
            "text": "This  article contains a list of all C++ operators and whether or not they are able to be overloaded.\nOperators can be overloaded as part of a class, or outside of class definitions.\nWhen overloading as part of a class, the object referred to by  this  is assumed to be the first parameter of the operator being overloaded.\nAlso, the overloaded operator can operate on and with private data and private member functions.  Operators overloaded globally must specify all parameters to the operator in question.\nBecause they are defined outside of the class, they cannot access private data or private member functions unless the operator is made to be a  friend .", 
            "title": "Overloading"
        }, 
        {
            "location": "/lab_week_04/#classes-within-classes", 
            "text": "Chapter 9 section 17 in your book  talks about using classes within classes.\nNothing special is happening here;\nonce a class is created, it can be used just about anywhere.  class A {\n    private:\n        int x, y;\n    public:\n        A(int x, int y) : x(x), y(y) {}\n        void setX(int x) { this- x = x; }\n        void setY(int y) { this- y = y; }\n        int  getX()      { return x; }\n        int  getY()      { return y; }\n};\n\nclass B {  // contains instances of A\n    private:\n        A pv1, pv2;\n};", 
            "title": "Classes Within Classes"
        }, 
        {
            "location": "/lab_week_04/#preprocessor-directives", 
            "text": "Preprocessor directives are very powerful tools that a programmer can use to make code more quickly.\nAll preprocessor directives start with the  octothorpe  ( # ).  #include  filename.h \n#include  filename.h   The  #include  directive finds a file specified, and places its contents where the  #include  statement was located.\nWhen the filename is surrounded with angle brackets ( ), the preprocessor will look in standard library locations for your file.\nWhen the filename is surrounded with quotation marks ( \"\" ), the preprocessor will look for the file in the same directory as the file you're trying to compile.", 
            "title": "Preprocessor Directives"
        }, 
        {
            "location": "/lab_week_04/#separate-files", 
            "text": "", 
            "title": "Separate Files"
        }
    ]
}