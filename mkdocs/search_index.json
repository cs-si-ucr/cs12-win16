{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to CS12 SI!\n\n\nThis is where all of the labs will be posted.\n\n\nWhat is SI?\n\n\nSupplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.\n\n\nWhat isn\u2019t SI?\n\n\nSupplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.\n\n\nWho should go?\n\n\nAnyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.\n\n\nHowever, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 10 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.\n\n\nWith that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.\n\n\nGuidelines:\n\n\n\n\nBe respectful - This includes silencing your cell phones\nand not using them during sessions.\n\n\nParticipate - You won\u2019t get very much out of SI if you\ndon\u2019t.\n\n\nNo food or drink besides water - This is a rule placed\nby the administration. I will enforce it.\n\n\nLate entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.\n\n\nSign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-cs12-si", 
            "text": "This is where all of the labs will be posted.", 
            "title": "Welcome to CS12 SI!"
        }, 
        {
            "location": "/#what-is-si", 
            "text": "Supplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.", 
            "title": "What is SI?"
        }, 
        {
            "location": "/#what-isnt-si", 
            "text": "Supplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.", 
            "title": "What isn\u2019t SI?"
        }, 
        {
            "location": "/#who-should-go", 
            "text": "Anyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.  However, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 10 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.  With that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.", 
            "title": "Who should go?"
        }, 
        {
            "location": "/#guidelines", 
            "text": "Be respectful - This includes silencing your cell phones\nand not using them during sessions.  Participate - You won\u2019t get very much out of SI if you\ndon\u2019t.  No food or drink besides water - This is a rule placed\nby the administration. I will enforce it.  Late entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.  Sign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Guidelines:"
        }, 
        {
            "location": "/lab_week_03/", 
            "text": "Lab 3: Structs and Classes\n\n\nStructs\n\n\nStructs are a way to create new datatypes that are combinations of smaller datatypes.\n\n\nHere's the syntax for creating a struct:\n\n\nstruct StructName {\n    Type1 field1;\n    Type2 field2;\n    // ...\n};  // \n-- Notice this semicolon\n\n\n\n\nAfter this point, there now exists a new type - a struct - called \nStructName\n, and it can be used like so:\n\n\nStructName myStruct;\nmyStruct.field1;     // expression of type Type1\nmyStruct.field2;     // expression of type Type2\n\n\n\n\nStructs define different fields.\nEach field gets its own type.\nWhen using the struct, each field is available through the dot operator.\n\n\nNow, you can use your new type like you would any other type.\n\n\n/* in containers */\nvector\nStructName\n v(20);        // a vector of StructName with a size of 20\n\n/* functions */\nvoid f1(StructName arg1);        // accepts StructName by value\nvoid f1(StructName\n arg1);       // accepts StructName by reference\nvoid f1(const StructName\n arg1); // accepts StructName by const reference\n\nStructName f2();                 // returns StructName\n\n\n\n\nClasses\n\n\nClasses are very similar to structs in that they can hold their own data.\nUnlike structs however, they can also hold contain their own methods.\n\n\nclass MyClass {\n    public:\n        Type1 publicData;\n        Type2 f1();\n    private:\n        Type3 privateData;\n        Type4 f2();\n};\n\n\n\n\nFirst, you should notice the \npublic\n and \nprivate\n keywords.\nThis is one of the big differences between structs and classes.\nIn a struct, all members are public.\nThis can't be changed.\nIn a class, the programmer decides whether each element is \npublic\n or \nprivate\n.\n\nprivate\n members can't be accessed with the dot operator.\n\n\nMyClass obj;\nobj.publicData;  // this is allowed\nobj.privateData; // this isn't allowed\n\n\n\n\nAnother difference is the concept of member functions.\nYou've already been using member functions.\nSome examples include \n.size()\n, \n.at(int)\n, and \n.find(...)\n.\n\n\nNow, combine your knowledge of member function usage and \npublic\n and \nprivate\n permissions, and it's easy to see how to use member functions:\n\n\nMyClass obj;\nobj.f1(); // allowed because it's public\nobj.f2(); // not allowed because it's private\n\n\n\n\nNotice that the parentheses mean that the member is a function, not just data.\n\n\nAn important thing you will need to learn now is \"encapsulation.\"\nThink about cars for a moment.\nTo drive a car well, you don't need to know how the engine works.\nYou don't need to keep track of every little piece;\ninstead you just focus on the steering wheel and pressing the pedals.\nSimilarly for classes, the users of your class shouldn't have access to the internal details.\nThey might mess something up!\nInstead, you provide a clean interface that abstracts the details away.\nRefer to your book on how to do this.\n\n\nAccessors, Mutators, and Private Helper Functions\n\n\nclass MyClass {\n    private:\n        Type data;\n        void helper();\n\n    public:\n        void accessor(int x) const; // this function can't change any private data\n        void mutator(int x);        // this function can change private data\n};\n\n\n\n\nMutators aren't \nrequired\n to change data;\nthey only have the ability to.\nAccessors that change private data will cause compiler errors.\n\n\nClass functions declared \nprivate\n are known as \"helper functions\".\nThis is due to the fact that they can only be called from within the class's own member functions.\n\n\nMyClass obj;\nobj.helper();  // not allowed\nobj.mutator(); // mutator is allowed to call helper\n\n\n\n\nNOTE: functions declared as const (accessors) aren't allowed to ever call a non-const function (mutator).\n\n\nConstructors\n\n\nclass MyClass {\n    public:\n        MyClass();      // notice: NO return type\n        MyClass(int x); // also, it can be overloaded to accept different parameters\n};\n\n\n\n\nConstructors exist to allow you to start your class at a known state.\nThey have \nno\n return type.\nWhen an object of your class is created, the constructor is called.\nIf you don't write a constructor for your class, a default constructor will be used.\n\n\nBonus\n\n\nIf you want to learn a cool trick that will make coding easier in the future, look up \ninitialization lists", 
            "title": "Lab Week 3"
        }, 
        {
            "location": "/lab_week_03/#lab-3-structs-and-classes", 
            "text": "", 
            "title": "Lab 3: Structs and Classes"
        }, 
        {
            "location": "/lab_week_03/#structs", 
            "text": "Structs are a way to create new datatypes that are combinations of smaller datatypes.  Here's the syntax for creating a struct:  struct StructName {\n    Type1 field1;\n    Type2 field2;\n    // ...\n};  //  -- Notice this semicolon  After this point, there now exists a new type - a struct - called  StructName , and it can be used like so:  StructName myStruct;\nmyStruct.field1;     // expression of type Type1\nmyStruct.field2;     // expression of type Type2  Structs define different fields.\nEach field gets its own type.\nWhen using the struct, each field is available through the dot operator.  Now, you can use your new type like you would any other type.  /* in containers */\nvector StructName  v(20);        // a vector of StructName with a size of 20\n\n/* functions */\nvoid f1(StructName arg1);        // accepts StructName by value\nvoid f1(StructName  arg1);       // accepts StructName by reference\nvoid f1(const StructName  arg1); // accepts StructName by const reference\n\nStructName f2();                 // returns StructName", 
            "title": "Structs"
        }, 
        {
            "location": "/lab_week_03/#classes", 
            "text": "Classes are very similar to structs in that they can hold their own data.\nUnlike structs however, they can also hold contain their own methods.  class MyClass {\n    public:\n        Type1 publicData;\n        Type2 f1();\n    private:\n        Type3 privateData;\n        Type4 f2();\n};  First, you should notice the  public  and  private  keywords.\nThis is one of the big differences between structs and classes.\nIn a struct, all members are public.\nThis can't be changed.\nIn a class, the programmer decides whether each element is  public  or  private . private  members can't be accessed with the dot operator.  MyClass obj;\nobj.publicData;  // this is allowed\nobj.privateData; // this isn't allowed  Another difference is the concept of member functions.\nYou've already been using member functions.\nSome examples include  .size() ,  .at(int) , and  .find(...) .  Now, combine your knowledge of member function usage and  public  and  private  permissions, and it's easy to see how to use member functions:  MyClass obj;\nobj.f1(); // allowed because it's public\nobj.f2(); // not allowed because it's private  Notice that the parentheses mean that the member is a function, not just data.  An important thing you will need to learn now is \"encapsulation.\"\nThink about cars for a moment.\nTo drive a car well, you don't need to know how the engine works.\nYou don't need to keep track of every little piece;\ninstead you just focus on the steering wheel and pressing the pedals.\nSimilarly for classes, the users of your class shouldn't have access to the internal details.\nThey might mess something up!\nInstead, you provide a clean interface that abstracts the details away.\nRefer to your book on how to do this.", 
            "title": "Classes"
        }, 
        {
            "location": "/lab_week_03/#accessors-mutators-and-private-helper-functions", 
            "text": "class MyClass {\n    private:\n        Type data;\n        void helper();\n\n    public:\n        void accessor(int x) const; // this function can't change any private data\n        void mutator(int x);        // this function can change private data\n};  Mutators aren't  required  to change data;\nthey only have the ability to.\nAccessors that change private data will cause compiler errors.  Class functions declared  private  are known as \"helper functions\".\nThis is due to the fact that they can only be called from within the class's own member functions.  MyClass obj;\nobj.helper();  // not allowed\nobj.mutator(); // mutator is allowed to call helper  NOTE: functions declared as const (accessors) aren't allowed to ever call a non-const function (mutator).", 
            "title": "Accessors, Mutators, and Private Helper Functions"
        }, 
        {
            "location": "/lab_week_03/#constructors", 
            "text": "class MyClass {\n    public:\n        MyClass();      // notice: NO return type\n        MyClass(int x); // also, it can be overloaded to accept different parameters\n};  Constructors exist to allow you to start your class at a known state.\nThey have  no  return type.\nWhen an object of your class is created, the constructor is called.\nIf you don't write a constructor for your class, a default constructor will be used.", 
            "title": "Constructors"
        }, 
        {
            "location": "/lab_week_03/#bonus", 
            "text": "If you want to learn a cool trick that will make coding easier in the future, look up  initialization lists", 
            "title": "Bonus"
        }, 
        {
            "location": "/lab_week_04/", 
            "text": "Lab 4: Classes, Syntactical Sugar, Compilation, and Makefiles\n\n\nThis\n\n\nclass Foo {\n    public:\n        Foo() {\n            this-\na = 0;\n            b = 0; // no confusion\n        }\n        Foo(int a, int b) {\n            // now, which \na\n does \na\n refer to?\n            /* this doesn't work for obvious reasons:\n            a = a;\n            b = b;\n            */\n            // using \nthis\n helps us clear the confusion up\n            this-\na = a; // a is the parameter\n            this-\nb = b; // b is the parameter\n        }\n    private:\n        int a, b;\n};\n\n\n\n\nThe keyword \nthis\n is used to access the implicit parameter's fields.\nTo use access fields of the implicit parameter, use the arrow operator (\n-\n).\n\n\nOverloading\n\n\nThis\n article contains a list of all C++ operators and whether or not they are able to be overloaded.\nOperators can be overloaded as part of a class, or outside of class definitions.\nWhen overloading as part of a class, the object referred to by \nthis\n is assumed to be the first parameter of the operator being overloaded.\nAlso, the overloaded operator can operate on and with private data and private member functions.\n\n\nOperators overloaded globally must specify all parameters to the operator in question.\nBecause they are defined outside of the class, they cannot access private data or private member functions unless the operator is made to be a \nfriend\n.\n\n\nClasses Within Classes\n\n\nChapter 9 section 17 in your book\n talks about using classes within classes.\nNothing special is happening here;\nonce a class is created, it can be used just about anywhere.\n\n\nclass A {\n    private:\n        int x, y;\n    public:\n        A(int x, int y) : x(x), y(y) {}\n        void setX(int x) { this-\nx = x; }\n        void setY(int y) { this-\ny = y; }\n        int  getX()      { return x; }\n        int  getY()      { return y; }\n};\n\nclass B {  // contains instances of A\n    private:\n        A pv1, pv2;\n};\n\n\n\n\nPreprocessor Directives\n\n\nPreprocessor directives are very powerful tools that a programmer can use to make code more quickly.\nAll preprocessor directives start with the \noctothorpe\n (\n#\n).\n\n\n#include \nfilename.h\n\n#include \nfilename.h\n\n\n\n\n\nThe \n#include\n directive finds a file specified, and places its contents where the \n#include\n statement was located.\nWhen the filename is surrounded with angle brackets (\n), the preprocessor will look in standard library locations for your file.\nWhen the filename is surrounded with quotation marks (\n\"\"\n), the preprocessor will look for the file in the same directory as the file you're trying to compile.\n\n\nSeparate Files\n\n\nWhen programs become very large, it is a good idea to split them up into smaller logical units so they are easier to maintain.\nThere is a way to do this that also has the added benefit of allowing for separate compilation;\ninstead of compiling every part of your program every time you want to build an executable, you can instead separate the code in such a way that only parts you change need to be recompiled.\n\n\n/* main.cpp */\n\n#include \niostream\n\n\nclass Foo { // class declaration\n    public:\n        Foo();        // default constructor\n        void hello(); // some function\n        // stuff\n        // ...\n    private:\n        // stuff\n        // ...\n};\n\n// class definition\nFoo::Foo() {}\n\nvoid Foo::hello() {\n    std::cout \n \nhello world\n \n std::endl;\n}\n\nint main() {\n    Foo a;\n    a.hello();\n}\n\n\n\n\nLet's say we're working with the single file \nmain.cpp\n above.\nHow would we break it up?\nStart by taking out the class and putting it in another file.\nWe'll call it \nfoo.cpp\n.\n\n\n/* foo.cpp */\n\n#include \niostream\n\n\nclass Foo { // class declaration\n    public:\n        Foo();        // default constructor\n        void hello(); // some function\n        // stuff\n        // ...\n    private:\n        // stuff\n        // ...\n};\n\n// class definition\nFoo::Foo() {}\n\nvoid Foo::hello() {\n    std::cout \n \nhello world\n \n std::endl;\n}\n\n\n\n\n/* main.cpp */\n\n#include \nfoo.cpp\n\n\nint main() {\n    Foo a;\n    a.hello();\n}\n\n\n\n\nNotice that \nmain.cpp\n doesn't actually use anything from \niostream\n, so it is not necessary to include it there.\nThis is a good first step.\nWe have logically separated all of the parts of our simple program.\nGenerally, each class will have its own file(s) containing all the code associated with it.\n\n\nWhat about the separate compilation I promised?\nIf you understand preprocessor directives, you can tell that we're basically ending up with our original \nmain.cpp\n, just using extra steps.\nLet's fix that:\n\n\n/* foo.h */\n\n#include \niostream\n\n\nclass Foo { // class declaration\n    public:\n        Foo();        // default constructor\n        void hello(); // some function\n        // stuff\n        // ...\n    private:\n        // stuff\n        // ...\n};\n\n\n\n\n/* foo.cpp */\n\n#include \nfoo.h\n\n\n// class definition\nFoo::Foo() {}\n\nvoid Foo::hello() {\n    std::cout \n \nhello world\n \n std::endl;\n}\n\n\n\n\n/* main.cpp */\n\n#include \nfoo.h\n\n\nint main() {\n    Foo a;\n    a.hello();\n}\n\n\n\n\nWow!\nThree files!!\nNow, we can perform separate compilation.\nPreviously, \ng++ main.cpp\n would have done the trick for us.\nNow, that won't work.\nInstead, we compile like this:\n\n\ng++ -c foo.cpp\ng++ -c main.cpp\ng++ foo.o main.o\n\n\n\n\nAlternatively, you could compile like this:\n\n\ng++ -c foo.cpp\ng++ main.cpp foo.o\n\n\n\n\nRemember how we are allowed to use prototypes for compilation, and give actual function definitions at a later point?\nThis is because there are actually two steps to building an executable.\nThe first is the compilation step.\nAll the code you write gets turned into machine language.\nNext is the linking step.\nAll the functions you used get \"linked\" into your executable.\nYou don't need to know the details of linking, but basically during compilation, a placeholder is put in for each function call, which is then filled in with an actual, correct value later.\n\n\nKnowing this, let's explore what's happening in the code above.\nWhen we attempt to compile \nfoo.cpp\n, \nfoo.cpp\n brings in \nfoo.h\n.\nNo reason to type anything twice, so we keep the class declaration in one spot, and that's usually the header file (ending in \n.h\n).\nThere's no \nmain\n function, but this is okay because we're only compiling for now.\nWe tell the compiler to only compile by sending the \n-c\n flag.\n\n\nNext, we attempt to compile \nmain.cpp\n.\nThe only thing \nmain.cpp\n needs to know to be compiled are the prototypes of \nFoo\n, and nothing else!\nWe're not linking yet, so we don't need the definitions.\n\n\nLastly, we link everything together.\nWhen compiling, we get \nobject code\n.\nThe file generated usually has the same name as the file compiled, but with a \n.o\n exstension instead of the original \n.cpp\n.\n\n\nIn the first compilation example, I created two object files, \nmain.o\n and \nfoo.o\n, and linked them together.\nIn the second compilation example, I created one object file, \nfoo.o\n, and then compiled and linked \nmain.cpp\n in a single step.\nEither way works, and is a matter of style.\nThe former is usually more preferable, because it's easier to remember;\njust do the exact same thing for all files, then link everything together!\nBoth allow for separate compilation.\n\n\nBut what does separate compilation mean, exactly?\nIf I were to change \nmain.cpp\n to the following:\n\n\n/* main.cpp */\n\n#include \nfoo.h\n\n\nint main() {\n    Foo a, b;\n    a.hello();\n    b.hello();\n}\n\n\n\n\nThe only thing I would need to do to recompile is the following:\n\n\ng++ -c main.cpp\ng++ main.o foo.o\n\n\n\n\nNotice how I did \nnot\n recompile \nfoo.cpp\n!\nThe old \ndefinitions\n for \nFoo\n are still in \nfoo.o\n, so I can still use it (assuming you didn't delete it).\nNow imagine if you have many large classes included in your project.\nCompiling the entire project every time you wanted to run it could be a time-consuming process.\nIt may take sever minutes to several hours, for larger projects.\nA solution to this problem is separate compilation;\norganize your files in such a way that you don't need to compile everything every time.\n\n\nNOTE: This doesn't mean you don't have to compile anything.\nYou still need to compile everything you \nchange\n.\nIf you change how \nFoo\n works, or add a function, you need to recompile and relink everything you change.\n\n\nInclusion Guards\n\n\nSeparate compilation is great, but there's one problem:\nwhat do I do if my header gets included in multiple places?\nWe can use preprocessor directives to make sure it only ever gets included once.\n\n\n/* foo.h */\n\n#ifndef FOO_H\n#define FOO_H\n\n#include \niostream\n\n\nclass Foo { // class declaration\n    public:\n        Foo();        // default constructor\n        void hello(); // some function\n        // stuff\n        // ...\n    private:\n        // stuff\n        // ...\n};\n\n#endif\n\n\n\n\n#ifndef\n asks the preprocessor if the term \nFOO_H\n is defined.\nIf it isn't, everything until the \n#endif\n is left in its place.\nOtherwise, if the term \nFOO_H\n has already been defined, everything until the \n#endif\n is removed (not permanently, of course, just for the purposes of compilation).\nThe \n#define\n defines the term \nFOO_H\n so the code can only ever be included for compilation once.\n\n\nIt's not a rule, but good practice is to name the defined term similarly to your header file.\nAlso, capitalizing every letter shows that it's a defined term.\n\n\nMakefiles\n\n\nall: main.o foo.o\n    g++ main.o foo.o -W -Wall -Werror\n\nmain.o: main.cpp foo.h\n    g++ -c main.cpp -W -Wall -Werror\n\nfoo.o: foo.cpp foo.h\n    g++ -c foo.cpp -W -Wall -Werror\n\n\n\n\nThis is the form that a \nMakefile\n follows.\nThe term before the colon is a \ntarget\n.\nTo the right of the colon on the same line are \nprerequisites\n.\nGenerally, filenames go here.\nIf the file doesn't exist, \nmake\n will try to create it using its target list.\nFor instance, because \nmain.o\n doesn't exist the first time \nmake\n is called, the \nmain.o\n target is then run.\nIf the prerequisites don't exist, and can't be created using one of the targets, \nmake\n will fail with an error.\nIf you run \nmake\n without specifying a target, the first target in the file will be used by default.\n\n\nAnother cool thing \nmake\n will do is execute certain targets based on wheter or not files have changed.\nIf you run make twice in a row without changing anything else, nothing will be done the second time because no files have changed and nothing more can be done.\nIf you change \nfoo.cpp\n, the \nfoo.o\n and \nall\n targets will be rerun.\n\n\nExercise 1\n\n\nExercise 2\n\n\nExercise 3", 
            "title": "Lab Week 4"
        }, 
        {
            "location": "/lab_week_04/#lab-4-classes-syntactical-sugar-compilation-and-makefiles", 
            "text": "", 
            "title": "Lab 4: Classes, Syntactical Sugar, Compilation, and Makefiles"
        }, 
        {
            "location": "/lab_week_04/#this", 
            "text": "class Foo {\n    public:\n        Foo() {\n            this- a = 0;\n            b = 0; // no confusion\n        }\n        Foo(int a, int b) {\n            // now, which  a  does  a  refer to?\n            /* this doesn't work for obvious reasons:\n            a = a;\n            b = b;\n            */\n            // using  this  helps us clear the confusion up\n            this- a = a; // a is the parameter\n            this- b = b; // b is the parameter\n        }\n    private:\n        int a, b;\n};  The keyword  this  is used to access the implicit parameter's fields.\nTo use access fields of the implicit parameter, use the arrow operator ( - ).", 
            "title": "This"
        }, 
        {
            "location": "/lab_week_04/#overloading", 
            "text": "This  article contains a list of all C++ operators and whether or not they are able to be overloaded.\nOperators can be overloaded as part of a class, or outside of class definitions.\nWhen overloading as part of a class, the object referred to by  this  is assumed to be the first parameter of the operator being overloaded.\nAlso, the overloaded operator can operate on and with private data and private member functions.  Operators overloaded globally must specify all parameters to the operator in question.\nBecause they are defined outside of the class, they cannot access private data or private member functions unless the operator is made to be a  friend .", 
            "title": "Overloading"
        }, 
        {
            "location": "/lab_week_04/#classes-within-classes", 
            "text": "Chapter 9 section 17 in your book  talks about using classes within classes.\nNothing special is happening here;\nonce a class is created, it can be used just about anywhere.  class A {\n    private:\n        int x, y;\n    public:\n        A(int x, int y) : x(x), y(y) {}\n        void setX(int x) { this- x = x; }\n        void setY(int y) { this- y = y; }\n        int  getX()      { return x; }\n        int  getY()      { return y; }\n};\n\nclass B {  // contains instances of A\n    private:\n        A pv1, pv2;\n};", 
            "title": "Classes Within Classes"
        }, 
        {
            "location": "/lab_week_04/#preprocessor-directives", 
            "text": "Preprocessor directives are very powerful tools that a programmer can use to make code more quickly.\nAll preprocessor directives start with the  octothorpe  ( # ).  #include  filename.h \n#include  filename.h   The  #include  directive finds a file specified, and places its contents where the  #include  statement was located.\nWhen the filename is surrounded with angle brackets ( ), the preprocessor will look in standard library locations for your file.\nWhen the filename is surrounded with quotation marks ( \"\" ), the preprocessor will look for the file in the same directory as the file you're trying to compile.", 
            "title": "Preprocessor Directives"
        }, 
        {
            "location": "/lab_week_04/#separate-files", 
            "text": "When programs become very large, it is a good idea to split them up into smaller logical units so they are easier to maintain.\nThere is a way to do this that also has the added benefit of allowing for separate compilation;\ninstead of compiling every part of your program every time you want to build an executable, you can instead separate the code in such a way that only parts you change need to be recompiled.  /* main.cpp */\n\n#include  iostream \n\nclass Foo { // class declaration\n    public:\n        Foo();        // default constructor\n        void hello(); // some function\n        // stuff\n        // ...\n    private:\n        // stuff\n        // ...\n};\n\n// class definition\nFoo::Foo() {}\n\nvoid Foo::hello() {\n    std::cout    hello world    std::endl;\n}\n\nint main() {\n    Foo a;\n    a.hello();\n}  Let's say we're working with the single file  main.cpp  above.\nHow would we break it up?\nStart by taking out the class and putting it in another file.\nWe'll call it  foo.cpp .  /* foo.cpp */\n\n#include  iostream \n\nclass Foo { // class declaration\n    public:\n        Foo();        // default constructor\n        void hello(); // some function\n        // stuff\n        // ...\n    private:\n        // stuff\n        // ...\n};\n\n// class definition\nFoo::Foo() {}\n\nvoid Foo::hello() {\n    std::cout    hello world    std::endl;\n}  /* main.cpp */\n\n#include  foo.cpp \n\nint main() {\n    Foo a;\n    a.hello();\n}  Notice that  main.cpp  doesn't actually use anything from  iostream , so it is not necessary to include it there.\nThis is a good first step.\nWe have logically separated all of the parts of our simple program.\nGenerally, each class will have its own file(s) containing all the code associated with it.  What about the separate compilation I promised?\nIf you understand preprocessor directives, you can tell that we're basically ending up with our original  main.cpp , just using extra steps.\nLet's fix that:  /* foo.h */\n\n#include  iostream \n\nclass Foo { // class declaration\n    public:\n        Foo();        // default constructor\n        void hello(); // some function\n        // stuff\n        // ...\n    private:\n        // stuff\n        // ...\n};  /* foo.cpp */\n\n#include  foo.h \n\n// class definition\nFoo::Foo() {}\n\nvoid Foo::hello() {\n    std::cout    hello world    std::endl;\n}  /* main.cpp */\n\n#include  foo.h \n\nint main() {\n    Foo a;\n    a.hello();\n}  Wow!\nThree files!!\nNow, we can perform separate compilation.\nPreviously,  g++ main.cpp  would have done the trick for us.\nNow, that won't work.\nInstead, we compile like this:  g++ -c foo.cpp\ng++ -c main.cpp\ng++ foo.o main.o  Alternatively, you could compile like this:  g++ -c foo.cpp\ng++ main.cpp foo.o  Remember how we are allowed to use prototypes for compilation, and give actual function definitions at a later point?\nThis is because there are actually two steps to building an executable.\nThe first is the compilation step.\nAll the code you write gets turned into machine language.\nNext is the linking step.\nAll the functions you used get \"linked\" into your executable.\nYou don't need to know the details of linking, but basically during compilation, a placeholder is put in for each function call, which is then filled in with an actual, correct value later.  Knowing this, let's explore what's happening in the code above.\nWhen we attempt to compile  foo.cpp ,  foo.cpp  brings in  foo.h .\nNo reason to type anything twice, so we keep the class declaration in one spot, and that's usually the header file (ending in  .h ).\nThere's no  main  function, but this is okay because we're only compiling for now.\nWe tell the compiler to only compile by sending the  -c  flag.  Next, we attempt to compile  main.cpp .\nThe only thing  main.cpp  needs to know to be compiled are the prototypes of  Foo , and nothing else!\nWe're not linking yet, so we don't need the definitions.  Lastly, we link everything together.\nWhen compiling, we get  object code .\nThe file generated usually has the same name as the file compiled, but with a  .o  exstension instead of the original  .cpp .  In the first compilation example, I created two object files,  main.o  and  foo.o , and linked them together.\nIn the second compilation example, I created one object file,  foo.o , and then compiled and linked  main.cpp  in a single step.\nEither way works, and is a matter of style.\nThe former is usually more preferable, because it's easier to remember;\njust do the exact same thing for all files, then link everything together!\nBoth allow for separate compilation.  But what does separate compilation mean, exactly?\nIf I were to change  main.cpp  to the following:  /* main.cpp */\n\n#include  foo.h \n\nint main() {\n    Foo a, b;\n    a.hello();\n    b.hello();\n}  The only thing I would need to do to recompile is the following:  g++ -c main.cpp\ng++ main.o foo.o  Notice how I did  not  recompile  foo.cpp !\nThe old  definitions  for  Foo  are still in  foo.o , so I can still use it (assuming you didn't delete it).\nNow imagine if you have many large classes included in your project.\nCompiling the entire project every time you wanted to run it could be a time-consuming process.\nIt may take sever minutes to several hours, for larger projects.\nA solution to this problem is separate compilation;\norganize your files in such a way that you don't need to compile everything every time.  NOTE: This doesn't mean you don't have to compile anything.\nYou still need to compile everything you  change .\nIf you change how  Foo  works, or add a function, you need to recompile and relink everything you change.", 
            "title": "Separate Files"
        }, 
        {
            "location": "/lab_week_04/#inclusion-guards", 
            "text": "Separate compilation is great, but there's one problem:\nwhat do I do if my header gets included in multiple places?\nWe can use preprocessor directives to make sure it only ever gets included once.  /* foo.h */\n\n#ifndef FOO_H\n#define FOO_H\n\n#include  iostream \n\nclass Foo { // class declaration\n    public:\n        Foo();        // default constructor\n        void hello(); // some function\n        // stuff\n        // ...\n    private:\n        // stuff\n        // ...\n};\n\n#endif  #ifndef  asks the preprocessor if the term  FOO_H  is defined.\nIf it isn't, everything until the  #endif  is left in its place.\nOtherwise, if the term  FOO_H  has already been defined, everything until the  #endif  is removed (not permanently, of course, just for the purposes of compilation).\nThe  #define  defines the term  FOO_H  so the code can only ever be included for compilation once.  It's not a rule, but good practice is to name the defined term similarly to your header file.\nAlso, capitalizing every letter shows that it's a defined term.", 
            "title": "Inclusion Guards"
        }, 
        {
            "location": "/lab_week_04/#makefiles", 
            "text": "all: main.o foo.o\n    g++ main.o foo.o -W -Wall -Werror\n\nmain.o: main.cpp foo.h\n    g++ -c main.cpp -W -Wall -Werror\n\nfoo.o: foo.cpp foo.h\n    g++ -c foo.cpp -W -Wall -Werror  This is the form that a  Makefile  follows.\nThe term before the colon is a  target .\nTo the right of the colon on the same line are  prerequisites .\nGenerally, filenames go here.\nIf the file doesn't exist,  make  will try to create it using its target list.\nFor instance, because  main.o  doesn't exist the first time  make  is called, the  main.o  target is then run.\nIf the prerequisites don't exist, and can't be created using one of the targets,  make  will fail with an error.\nIf you run  make  without specifying a target, the first target in the file will be used by default.  Another cool thing  make  will do is execute certain targets based on wheter or not files have changed.\nIf you run make twice in a row without changing anything else, nothing will be done the second time because no files have changed and nothing more can be done.\nIf you change  foo.cpp , the  foo.o  and  all  targets will be rerun.", 
            "title": "Makefiles"
        }, 
        {
            "location": "/lab_week_04/#exercise-1", 
            "text": "", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/lab_week_04/#exercise-2", 
            "text": "", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/lab_week_04/#exercise-3", 
            "text": "", 
            "title": "Exercise 3"
        }
    ]
}